# 啊哈算法

## 排序

### 桶排序

- 时间复杂度O(M+N)
- 对空间要求大

### 冒泡排序

- 【交换】
- 时间复杂度O(N^2)

### 快速排序

- 【折半】
- 时间复杂度O(N*logN)

## 队列、栈、链表

### 队列queue

- 先进先出
- head\data\tail

### 栈stack

- 先进后出

	- 回文、浏览器前进后退、{}符号闭合

- top\data

### 链表

- 指针
- 动态分配内存函数malloc

## 搜索

### dfs 深度优先搜索

- 递归

	- 解决当前应该怎么办
	- eg:全排列、迷宫

### bfs 广度优先搜索

- 队列

	- eg:迷宫、炸弹人、宝岛探险

## 图

### 术语

- 图
- 有向图

	- 有向边

		- 出边
		- 入边
		- 始点
		- 终点

- 无向图

### 图的存储

- 二维数组存储
- 图的邻接矩阵存储法

	- 稠密图

### 图的深度优先遍历

- 主要思想
- eg:城市地图

### 图的广度优先遍历

- 主要思想
- eg:最少转机
- 更适合所有边权值相同的情况

## 最短路径

### Floyd-Warshall(弗洛伊德)算法

- 多源最短路径
- 核心代码
- 时间复杂度O(N^3)
- "负权回路"没有最短路径

### Dijkstra(迪杰斯特拉)算法

- 单源最短路径
- 核心代码
- 时间复杂度O((M+N)*logN)
- 使用数组实现邻接表

	- 稀疏图

- 基于贪心策略，不能有负权边

### Bellman–Ford(贝尔曼-福特)算法

- 解决负权边
- 完美的最短路算法
- 核心代码
- 时间复杂度O(M*N)

### 队列优化的Bellman–Ford

### 最短路径算法对比分析

## 树

### 什么是树

- 是不包含回路的无向图
- 树的特点
- 运用场景

### 二叉树

- 满二叉树
- 完全二叉树

	- 一维数组存储
	- 规律

		- 最后一个非叶子节点是第n/2个节点

### 堆Heap

- 一种特殊的完全二叉树
- 优先队列

	- 支持插入元素和寻找最大（小）值元素的数据结构

- 最小堆
- 最大堆
- 堆排序：时间复杂度O(N*logN)
- eg:求一个数列中第K大（小）的树，O(N*logK)

### 并查集

- 通过一个一维数组实现
- 不相交集数据结构

## 更多

### 最小生成树

- eg:镖局运镖
- Kruskal算法

	- 时间复杂度O(M*logM)，M是边数
	- 适用于稀疏图

- Prim算法

	- 未堆优化

		- 时间复杂度O(N^2)
		- 适用于稠密图

	- 堆优化后

		- 时间复杂度O(M*logN)
		- 适用于稀疏图

### 图的割点

- eg:重要城市
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

### 图的割边

- eg:关键道路
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

- 可见一个算法要选择合适的数据结构是非常重要的

### 二分图最大匹配

- 二分图定义
- 增广路
- eg:我要做月老
- 时间复杂度O(M*N)
- 运用场景

	- 任务调度
	- 工作安排

- 使用着色法判断二分图

*XMind: ZEN - Trial Version*