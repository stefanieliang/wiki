# 排序算法

## 0.概述

![sort](imgs/排序/sort.png)

![sort2](imgs/排序/sort2.png)
## 1.冒泡排序

​	冒泡排序是一种简单直观的排序算法。它重复的走访过要排序的数列，一次比较两个元素。

- 时间复杂度
- 空间复杂度

### 算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个；
2. 对每一对相邻元素作同样工作，从开始第一对到结尾的最后一对。这一步做完后，最后的元素会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个。

### 动图演示

![冒泡排序](imgs/排序/bubbleSort.gif)

### 代码实现

```javascript
let swap = function (arr, from, to) {
    [arr[from], arr[to]] = [arr[to], arr[from]]
}

let judge = function (a, b) {
    return a > b
}

let bubbleSort = arr => {
    let len = arr.length; //循环优化
    for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
            if (judge(arr, j, j + 1)) { // 相邻元素两两对比
                swap(arr, j, j + 1) // 元素交换
            }
        }
    }
    return arr;
}
```



## 2.选择排序



- 时间复杂度O(n²) 
- 空间复杂度

### 算法步骤

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 重复第二步，知道所有元素均排序完毕。

### 动图演示

![选择排序](imgs/排序/selectionSort.gif)

### 代码实现

```javascript
/** 
 * 选择排序
 * 从小到大
 */

const data = [1, 8, 4, 9, 2, 10, 0, -1]

let swap = function (arr, from, to) {
    [arr[from], arr[to]] = [arr[to], arr[from]]
}

let judge = function (arr, a, b) {
    return arr[a] > arr[b]
}

let selectionSort = arr => {
    let len = arr.length; //循环优化
    let minIndex;
    for (let i = 0; i < len - 1; i++) {
        minIndex = i;
        for (let j = i + 1; j < len; j++) {
            if (judge(arr, minIndex, j)) { // 寻找最小的数
                minIndex = j; // 将最小数的索引保存
            }
        }
        swap(arr, minIndex, i)
    }
    return arr;
}
```



## 3.插入排序

​	类比揭扑克牌。它的原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

- 时间复杂度
- 空间复杂度

### 算法步骤

1. 将待排序序列第一个元素看作一个有序序列，把第二个元素到最后一个元素当成未排序序列；
2. 从头到尾一次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插到相等元素的后面）

### 动图演示

![插入排序](imgs/排序/insertionSort.gif)

### 代码实现

```javascript
const data = [1, 8, 4, 9, 2, 10, 0, -1]

let swap = function (arr, from, to) {
    [arr[from], arr[to]] = [arr[to], arr[from]]
}

let judge = function (arr, a, b) {
    return arr[a] > arr[b]
}

let insertionSort = arr => {
    let len = arr.length; //循环优化
    for (let i = 1; i < len; i++) {
        for (let j = i; j > 0; j--) {
            if (judge(arr, j - 1, j)) {
                swap(arr, j - 1, j)
            }
        }
    }
    return arr;
}
```



## 4.希尔排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示



### 代码实现

## 5.归并排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示

![归并排序](imgs/排序/mergeSort.gif)

### 代码实现

## 6.快速排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示

### 代码实现

## 7.堆排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示

### 代码实现

## 8.计数排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示

### 代码实现

## 9.桶排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示

### 代码实现

## 10.基数排序



- 时间复杂度
- 空间复杂度

### 算法步骤

### 动图演示

### 代码实现

### 



