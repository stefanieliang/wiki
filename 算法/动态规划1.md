动态规划中三个重要的概念：【最优子结构】、【边界】、【状态转移公式】

#### **题一、爬楼问题（一个维度）：**

有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法。

##### 问题建模

- 最优子结构：F(9)、F(8)
- 边界：F(1)、F(2)
- 状态转移方程：F(n) = F(n-1) + F(n-2)

##### 求解问题

- 递归求解：时间复杂度O(2^n)

  > 递归求解的时间复杂度是指数级的。

  ```javascript
  // 递归求解
  function getClimbingWays(n) {
      if (n < 1) {
          return 0;
      }
      if (n === 1) {
          return 1
      }
      if (n === 2) {
          return 2
      }
      return getClimbingWays(n - 1) + getClimbingWays(n - 2)
  }
  ```

  ![](D:\SourceCode\wiki\算法\imgs\动态规划1\爬楼-递归解.jpg)

- 备忘录算法：时间复杂度O(n)、空间复杂度O(n)

  ```javascript
  // 备忘录算法：增加了缓存
  function getClimbingWays2(n) {
      let map = new Map();
      if (n < 1) {
          return 0;
      }
      if (n === 1) {
          return 1
      }
      if (n === 2) {
          return 2
      }
      if (map.has(n)) {
          return map.get(n)
      } else {
          let value = getClimbingWays2(n - 1) + getClimbingWays2(n - 2);
          map.set(n, value)
          return value
      }
  }
  ```

  

- 动态规划:时间复杂度O(n)、空间复杂度O(1)

  ```javascript
  // 动态规划：自底向上计算，可只缓存2个数据
  function getClimbingWays3(n) {
      if (n < 1) {
          return 0;
      }
      if (n === 1) {
          return 1
      }
      if (n === 2) {
          return 2
      }
  
      let a = 1;
      let b = 2;
      let temp = 0;
  
      for (let i = 3; i <= n; i++) {
          temp = a + b;
          [a, b] = [b, temp]
      }
      return temp;
  }
  ```

  ![](D:\SourceCode\wiki\算法\imgs\动态规划1\爬楼-动态规划.png)

#### **题二、工人挖矿问题（两个维度）：**

​	有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

![](D:\SourceCode\wiki\算法\imgs\动态规划1\国王和金矿.png)

##### 问题建模

- 最优子结构：
- 边界：
- 状态转移方程：

##### 求解问题

- 排列组合：时间复杂度O(2^n)

  > 排列组合求解的时间复杂度是指数级的。

参考文档

[漫画：什么是动态规划？（整合版） ](https://www.sohu.com/a/149075950_684445)