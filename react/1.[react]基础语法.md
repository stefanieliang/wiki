

## 一、环境准备

1. 安装脚手架	`npm install -g create-react-app`
2. 创建项目 `create-react-app 项目名  `

## 二、基础语法

### 1.Hello **World**

```html
<div id="root">root</div>

<!-- 1.引入 react react-dom -->
<script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>

<!-- 2.引入 babel 用于解析 JSX -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- 3.在 script 标签中添加 type="text/babel" -->
<script  type="text/babel">
            ReactDOM.render(
                  <h1>Hello, world!</h1>,
                  document.getElementById('root')
            );
</script>
```



### 2.JSX 简介

### 3.容器组件 vs 展示组件

#### 	1.不区分的情况

```javascript
// CommentList.js

import React from 'react'
class CommentList extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            comments: []
        }
    }

    componentDidMount() {
        setTimeout(
            this.setState({
                comments: ['嘿嘿', '哈哈', '呼呼']
            }), 3000)
    }

    render() {
        return (
            <div>
                <p>容器组件 和 展示组件不分离的情况</p>
                <ul>
                    {this.state.comments.map(this.renderComment)}
                </ul>
            </div>
        )
    }

    renderComment = (v) => {
        return (
            <li key={v}>{v}</li>
        )
    }
}
```

#### 	2.区分的情况

```javascript
// CommentListContainer.js

import CommentListUI from './CommentListUI'

class CommentListContainer extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            comments: []
        }
    }

    componentDidMount() {
        setTimeout(
            this.setState({
                comments: ['嘿嘿', '哈哈', '呼呼']
            }), 3000)
    }

    render() {
        return (
            <div>
                <CommentListUI comments={this.state.comments}></CommentListUI>
            </div>
        )
    }
}

// CommentListUI.js

class CommentListUI extends React.Component {
    constructor(props) {
        super(props)
    }

    render() {
        return (
            <div>
                <p>容器组件 和 展示组件 分开啦~~</p>
                <ul>
                    {this.props.comments.map(this.renderComment)}
                </ul>
            </div>
        )
    }

    renderComment = (v) => {
        return (
            <li key={v}>{v}</li>
        )
    }
}

```

#### 	3.二者区别

| 容器组件（Smart/Container Components）                       | 展示组件（Dumb/Presentational Components）                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 关注事务如何工作                                             | 关注事务的展示                                               |
| 可能包含展示和容器组件，并且不会有 DOM 标签和 CSS 样式       | 可能包含展示和容器组件，并且一般会有 DOM 标签和 CSS 样式     |
| 提供数据和行为给容器组件或其他展示组件                       | 常常允许通过 this.props.children 传递                        |
| 调用 flux action 并且提供他们的回调给展示组件                | 对第三方没有任何依赖，比如 store 或者 flux action            |
| 作为数据源，通常采用较高阶的组件，而不是自己写，比如 React Redux 的 connect() , Relay 的 createContainer() , Flux Utils 的 Container.create() | 不要指定数据如何加载和变化                                   |
|                                                              | 仅通过属性获取数据和回调                                     |
|                                                              | 很少有自己的状态，即使有，也是自己的UI状态                   |
|                                                              | 除非他们需要自己的状态，生命周期，或性能优化，才会被写为功能组件 |

#### 	4.容器组件和展示组件分离的好处：

1. 展示和容器更好的分离，更好的理解应用程序和UI。
2. 重用性高，展示组件可以用于多个不同的 state 数据源。

### 4.`React.PureComponent`

`React.PureComponent` 与 [`React.Component`](https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent) 很相似。两者的区别在于 [`React.Component`](https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent) 并未实现 [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)，而 `React.PureComponent` 中以 **浅层** 对比 prop 和 state 的方式来实现了该函数。

如果赋予 React 组件相同的 props 和 state，`render()` 函数会渲染相同的内容，那么在某些情况下使用 `React.PureComponent` 可提高性能。

> 注意
>
> `React.PureComponent` 中的 `shouldComponentUpdate()` 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 `React.PureComponent`，或者在深层数据结构发生变化时调用 [`forceUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#forceupdate) 来确保组件被正确地更新。你也可以考虑使用 [immutable 对象](https://facebook.github.io/immutable-js/)加速嵌套数据的比较。
>
> 此外，`React.PureComponent` 中的 `shouldComponentUpdate()` 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。

### 5.`React.memo`

```
const MyComponent = React.memo(function MyComponent(props) {
  /* 使用 props 渲染 */
});
```

`React.memo` 为[高阶组件](https://zh-hans.reactjs.org/docs/higher-order-components.html)。

如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 `React.memo` 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。

`React.memo` 仅检查 props 变更。如果函数组件被 `React.memo` 包裹，且其实现中拥有 [`useState`](https://zh-hans.reactjs.org/docs/hooks-state.html) 或 [`useContext`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext) 的 Hook，当 context 发生变化时，它仍会重新渲染。

默认情况下其只会对复杂对象做**浅层**对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。

```
function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
  /*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual);
```

此方法仅作为**[性能优化](https://zh-hans.reactjs.org/docs/optimizing-performance.html)**的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。

> 注意
>
> 与 class 组件中 [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate) 方法不同的是，如果 props 相等，`areEqual` 会返回 `true`；如果 props 不相等，则返回 `false`。这与 `shouldComponentUpdate` 方法的返回值相反。

### 6.高阶组件 HOC

​	高阶组件HOC（`higherOrderComponent`）是 React 中用于复用组件逻辑的一种高级技巧。HOC自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

​	具体而言，**高阶组件是参数为组件，返回值为新组件的函数。约定以  `with` 开头，可链式调用。**

```
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

​	组件是将 props 转换为 `UI`，而高阶组件是将组件转换为另一个组件。

#### 1.场景一：为组件增加属性

#### 2.场景二：日志组件

#### 3.装饰器模式

`npm install --save-dev babel-plugin-transform-deractors-degancy`

### 7.组件通信 context

### 8.React 未来

