# 啊哈算法

[TOC]

## 排序

### 桶排序

- 时间复杂度O(M+N)
- 对空间要求大

### 冒泡排序

- 【交换】
- 时间复杂度O(N^2)

### 快速排序

- 【折半】
- 时间复杂度O(N*logN)

## 队列、栈、链表

### 队列queue

#### 原则：先进先出 FIFO

#### 结构体类型：data\head\tail

```c
struct queue
{
    int data[100];// 队列的主体，用来存储内容
    int head;// 队首
    int tail;// 队尾
};

// head == tail 说明是空队列
```

#### 场景：排队买票

### 栈stack

#### 原则：后进先出

#### 结构体类型：data\top

```c
struct stack
{
	int data[10];
    int top;
};

// top == 0 说明是空栈
```

#### 场景：浏览器前进后退、回文、{}符号闭合

> 判断回文思路：
>
> 1. 创建栈s[]；
> 2. 找到栈的中间位置mid（把栈分为 A 和 B 两部分）；
> 3. 循环 B ，一一和栈 A 的栈顶对比，相等则出栈 top--；
> 4. 最后 top == 0，则说明是回文。

```c
#include <stdio.h> 
#include <string.h> 
int main() 
{ 
 char a[101],s[101]; 
 int i,len,mid,next,top; 
 
 gets(a); //读入一行字符串
 len=strlen(a); //求字符串的长度
 mid=len/2-1; //求字符串的中点
 
 top=0;//栈的初始化
 //将mid前的字符依次入栈
 for(i=0;i<=mid;i++) 
 s[++top]=a[i]; 
 
 //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 
 if(len%2==0) 
 next=mid+1; 
 else 
 next=mid+2; 
 
 //开始匹配
 for(i=next;i<=len-1;i++)
 { 
 if(a[i]!=s[top]) 
 break; 
 top--; 
 } 
 
 //如果top的值为0，则说明栈内所有的字符都被一一匹配了
 if(top==0) 
 printf("YES"); 
 else 
 printf("NO"); 
 getchar();getchar(); 
 return 0; 
}
```



### 纸牌游戏（队列和栈的应用）

​	游戏的规则是这样的：将一副扑克牌平均分成两份，每人拿一份。小哼先拿出手中的第一张扑克牌放在桌上，然后小哈也拿出手中的第一张扑克牌，并放在小哼刚打出的扑克牌的上面，就像这样两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，即可将两张相同的牌及其中间所夹的牌全部取走，并依次放到自己手中牌的末尾。当任意一人手中的牌全部出完时，游戏结束，对手获胜。

> 解题思路：
>
> 小哼有两种操作，分别是出牌和赢牌。这恰好对应队列的两个操作，出牌就是出队，赢牌就是入队。小哈的操作和小哼是一样的。
>
> 而桌子就是一个栈，每打出一张牌放到桌上就相当于入栈。当有人赢牌的时候，依次将牌从桌上拿走，这就相当于出栈。
>
> 那如何解决赢牌的问题呢？赢牌的规则是：如果某人打出的牌与桌上的某张牌相同，即可将两张牌以及中间所夹的牌全部取走。
>
> 1. 初始化2个队列q1，q2（先进先出），用于存储小哼小哈手里的牌；初始化1个栈s（后进先出），用于存储桌面上的牌；
> 2. q1非空 且 q2非空时，循环步骤3-4；
> 3. 小哼出牌，判断小哼当前是否赢牌`book[t]==1`（t是当前牌）；若赢牌，则小哼队列q1+赢的牌，桌面栈s-赢的牌，桌面标记取消此牌`book[s.data[s.top]]=0`；若不赢，则小哼队列q1--，桌面栈s++；
> 4. 小哈出牌，逻辑同小哼；
> 5. q1空了，小哼输牌；q2空了，小哈输牌。

```c
#include <stdio.h> 
struct queue 
{ 
 int data[1000]; 
 int head; 
 int tail; 
};
struct stack 
{ 
 int data[10]; 
 int top; 
}; 
int main() 
{ 
 struct queue q1,q2; 
 struct stack s; 
 int book[10]; 
 int i,t; 
 
 //初始化队列
 q1.head=1; q1.tail=1; 
 q2.head=1; q2.tail=1; 
 //初始化栈
 s.top=0; 
 //初始化用来标记的数组，用来标记哪些牌已经在桌上
 for(i=1;i<=9;i++) 
 book[i]=0; 
 
 //依次向队列插入6个数
 //小哼手上的6张牌
 for(i=1;i<=6;i++) 
 { 
 scanf("%d",&q1.data[q1.tail]); 
 q1.tail++; 
 } 
 //小哈手上的6张牌
 for(i=1;i<=6;i++) 
 { 
 scanf("%d",&q2.data[q2.tail]); 
 q2.tail++; 
 } 
 while(q1.head<q1.tail && q2.head<q2.tail ) //当队列不为空的时候执行循环
 { 
 t=q1.data[q1.head];//小哼出一张牌
 //判断小哼当前打出的牌是否能赢牌
 if(book[t]==0) //表明桌上没有牌面为t的牌
     { 
 //小哼此轮没有赢牌
 q1.head++; //小哼已经打出一张牌，所以要把打出的牌出队
 s.top++; 
 s.data[s.top]=t; //再把打出的牌放到桌上，即入栈
 book[t]=1; //标记桌上现在已经有牌面为t的牌
 } 
 else 
 { 
 //小哼此轮可以赢牌
 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队
 q1.data[q1.tail]=t;//紧接着把打出的牌放到手中牌的末尾
 q1.tail++; 
 while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾
 { 
 book[s.data[s.top]]=0;//取消标记
 q1.data[q1.tail]=s.data[s.top];//依次放入队尾
 q1.tail++; 
 s.top--; //栈中少了一张牌，所以栈顶要减1 
 } 
 } 
 
 t=q2.data[q2.head]; //小哈出一张牌
 //判断小哈当前打出的牌是否能赢牌
 if(book[t]==0) //表明桌上没有牌面为t的牌
 { 
 //小哈此轮没有赢牌
 q2.head++; //小哈已经打出一张牌，所以要把打出的牌出队
 s.top++; 
 s.data[s.top]=t; //再把打出的牌放到桌上，即入栈
 book[t]=1; //标记桌上现在已经有牌面为t的牌 
 } 
 else 
 { 
 //小哈此轮可以赢牌
 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队
 q2.data[q2.tail]=t;//紧接着把打出的牌放到手中牌的末尾
 q2.tail++; 
 while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾
 { 
 book[s.data[s.top]]=0;//取消标记
     q2.data[q2.tail]=s.data[s.top];//依次放入队尾
 q2.tail++; 
 s.top--; 
 } 
 } 
 } 
 
 if(q2.head==q2.tail) 
 { 
 printf("小哼win\n"); 
 printf("小哼当前手中的牌是"); 
 for(i=q1.head;i<=q1.tail-1;i++) 
 printf(" %d",q1.data[i]); 
 if(s.top>0) //如果桌上有牌则依次输出桌上的牌
 { 
 printf("\n桌上的牌是"); 
 for(i=1;i<=s.top;i++) 
 printf(" %d",s.data[i]); 
 } 
 else 
 printf("\n桌上已经没有牌了"); 
 } 
 else 
 { 
 printf("小哈win\n"); 
 printf("小哈当前手中的牌是"); 
 for(i=q2.head;i<=q2.tail-1;i++) 
 printf(" %d",q2.data[i]); 
 if(s.top>0) //如果桌上有牌则依次输出桌上的牌
 { 
 printf("\n桌上的牌是"); 
 for(i=1;i<=s.top;i++) 
 printf(" %d",s.data[i]); 
 } 
 else 
 printf("\n桌上已经没有牌了"); 
 } 
 
 getchar();getchar(); 
 return 0; 
}
```



### 链表

#### 指针

```c
int *p;// 定义指针p，一个存放整数的内存空间
double *p;// 定义指针q，一个存放浮点数的内存空间

// & 取地址符
p=&a;// 指针p获取变量a的地址

// * 间接运算符，用于获取指针p所指向的内存中的值
*p;
```

#### 动态分配内存函数malloc

```c
int *p;//定义一个指针p
p=(int *)malloc(sizeof(int));//指针p获取动态分配的内存空间地址
*p=10;//向指针p所指向的内存中存入10
```

#### 结构体类型

```c
struct node
{
    int data;
    struct node *next;
};
```

#### 模拟链表

链表还有另外一种使用数组来实现的方式，叫做模拟链表。

链表中的每一个结点只有两部分。我们可以用一个数组 `data[]` 来存储序列中的每一个数；用另一个数组 `right[]` 来存放序列中每一个数右边的数是谁（这里存储的是 `data[]` 的下标哦）。

## 搜索

### dfs 深度优先搜索

#### 递归

- 解决当前应该怎么办
- eg:全排列、迷宫

#### dfs的基本模型

```c
void dfs(int step)
{
	判断边界
    尝试每一种可能 for(i=1;i<=n;i++)
    {
        继续下一步 dfs(step+1)
    }
    返回
}
```

#### 【一个题目】全排列

手中有编号为1~9的九张扑克牌，排列使得`[][][]+[][][]=[][][]`成立，注意A+B=C和B+A=C属于同一种组合，求一共有多少种组合？

- 枚举法（暴力解）

  ```javascript
  // 枚举法（暴力解）
  let enumeration = function () {
      let a, b, c, d, e, f, g, h, i, total = 0;
      for (a = 1; a <= 9; a++) { // 第一个数的百位
          for (b = 1; b <= 9; b++) { // 第一个数的十位
              for (c = 1; c <= 9; c++) { // 第一个数的个位
  
                  for (d = 1; d <= 9; d++) { // 第二个数的百位
                      for (e = 1; e <= 9; e++) { // 第二个数的十位
                          for (f = 1; f <= 9; f++) { // 第二个数的个位
  
                              for (g = 1; g <= 9; g++) { // 第三个数的百位
                                  for (h = 1; h <= 9; h++) { // 第三个数的十位
                                      for (i = 1; i <= 9; i++) { // 第三个数的个位
  
                                          if (a != b && a != c && a != d && a != e && a != f && a != g && a != h && a != i &&
                                              b != c && b != d && b != e && b != f && b != g && b != h && b != i &&
                                              c != d && c != e && c != f && c != g && c != h && c != i &&
                                              d != e && d != f && d != g && d != h && d != i &&
                                              e != f && e != g && e != h && e != i &&
                                              f != g && f != h && f != i &&
                                              g != h && g != i &&
                                              h != i &&
                                              (a * 100 + b * 10 + c) + (d * 100 + e * 10 + f) == g * 100 + h * 10 + i) {
                                              total++;
                                          }
  
                                      }
                                  }
                              }
  
                          }
                      }
                  }
  
              }
          }
      }
      return total / 2
  }
  console.log('枚举法（暴力解）::', enumeration())
  ```

  

- 标记法（用 book[] 来解决互不相等的问题）

  ```javascript
  // 标记法（用 book[] 来解决互不相等的问题）
  let bookExec = function () {
      let a = new Array(10),
          i,
          total = 0,
          book = new Array(10),
          sum;
      for (a[1] = 1; a[1] <= 9; a[1]++) { // 第一个数的百位
          for (a[2] = 1; a[2] <= 9; a[2]++) { // 第一个数的十位
              for (a[3] = 1; a[3] <= 9; a[3]++) { // 第一个数的个位
  
                  for (a[4] = 1; a[4] <= 9; a[4]++) { // 第二个数的百位
                      for (a[5] = 1; a[5] <= 9; a[5]++) { // 第二个数的十位
                          for (a[6] = 1; a[6] <= 9; a[6]++) { // 第二个数的个位
  
                              for (a[7] = 1; a[7] <= 9; a[7]++) { // 第三个数的百位
                                  for (a[8] = 1; a[8] <= 9; a[8]++) { // 第三个数的十位
                                      for (a[9] = 1; a[9] <= 9; a[9]++) { // 第三个数的个位
  
                                          book.fill(0); // 初始化 book[]
                                          for (i = 1; i <= 9; i++) {
                                              book[a[i]] = 1; // 如果某个数出现过就标记
                                          }
                                          // 统计出现了多少个不同的数
                                          sum = 0;
                                          for (i = 1; i <= 9; i++) {
                                              sum += book[i]
                                          }
  
                                          // 如果正好出现9个不同的数，且满足等式条件
                                          if (sum == 9 && (a[1] * 100 + a[2] * 10 + a[3]) + (a[4] * 100 + a[5] * 10 + a[6]) == (a[7] * 100 + a[8] * 10 + a[9])) {
                                              total++;
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
      return total / 2
  }
  console.log('标记法::', bookExec()) // 执行发现，标记法好慢哦！
  ```

- 递归（深度优先遍历搜索）

  ```javascript
  // 递归（深度优先遍历搜索）
  let a = new Array(10),
      book = new Array(10).fill(0),
      total = 0;
  let dfs = function (step = 1) {
      let i;
      if (step == 10) { // 站在了第十个盒子前，说明前9个盒子已装好扑克牌
          if ((a[1] * 100 + a[2] * 10 + a[3]) + (a[4] * 100 + a[5] * 10 + a[6]) == (a[7] * 100 + a[8] * 10 + a[9])) {
              total++;
          }
      }
      // 此时站在第step个盒子面前，该放哪个扑克牌呢？
      // 按照1，2，...n一一尝试
      for (i = 1; i <= 9; i++) {
          if (book[i] == 0) { // 说明牌i还在手上
              a[step] = i; // 将牌i放入第step个盒子中
              book[i] = 1; // 标记牌i已不在手上
  
              dfs(step + 1); // 走到下一个盒子面前，递归
              book[i] = 0; // 一定要将刚才尝试的牌收回！！
          }
      }
  }
  dfs();
  console.log('递归（深度优先遍历搜索）::', total / 2)
  ```

#### 【一个题目】迷宫

​	小哼解救小哈。迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。注意障碍物是不能走的，且不能走到迷宫之外。你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。

```javascript
/**
 * 小哼解救小哈。
 * 迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。
 * 注意障碍物是不能走的，且不能走到迷宫之外。
 * 你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。
 */

// 初始化一个5行4列的迷宫，1表示障碍物
let n = 5,
    m = 4;
let map = [
    [0, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1]
]
// 小哈所在的位置
let p = 3,
    q = 2;


// 用来标记迷宫上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]
let min = 999999; // 存储最短路径

let dfs = function (x, y, step) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    // 判断找到小哈，并返回最短路径
    if (x == p && y == q) {
        min = Math.min(step, min)
    }

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是障碍物 && 未走过
        if (map[tx][ty] == 0 && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, step + 1); // 尝试下一点
            book[tx][ty] = 0; // 取消这个点的标记
        }
    }

}
dfs(0, 0, 0);
console.log("找到小哈需要走的最短路径：：", min)
```

#### 【一个题目】炸弹人

```javascript
/**
 * 炸弹人
 * 
 */


// 初始化一个13行13列的迷宫，#表示墙，G表示敌人，.表示空地
let n = 13,
    m = 13;
let map = [
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', 'G', 'G', '.', '#'],
    ['#', '#', '#', '.', '#', 'G', '#', 'G', '#', 'G', '#', 'G', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', 'G', '#'],
    ['#', 'G', '#', '.', '#', '#', '#', '.', '#', 'G', '#', 'G', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '.', '#', '.', 'G', 'G', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', '.', '#', '.', '#', '.', '#'],
    ['#', '#', 'G', '.', '.', '.', 'G', '.', '.', '.', '.', '.', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', '#', '#', '.', '#', 'G', '#'],
    ['#', '.', '.', '.', 'G', '#', 'G', 'G', 'G', '.', 'G', 'G', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', 'G', '#', '.', '#', 'G', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', '.', 'G', 'G', '#'],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#']
]

// 用来标记迷宫上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]
let max = 0,
    mx, my;

let dfs = function (x, y) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k, sum = 0;

    sum = getNum(x, y);
    if (sum > max) {
        max = sum;
        mx = x; // 记录当前点的坐标
        my = y;
    }

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点是空地 && 未走过
        if (map[tx][ty] == '.' && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记-----这一行不执行也可以
        }
    }

}
dfs(3, 3);
console.log(`将炸弹放在（${mx},${my}）处，最多可消灭 ${max} 个敌人`)


// 【帮助方法】计算每个点上可消除的敌人数
function getNum(i, j) {
    let sum, x, y;
    sum = 0;

    // 向上统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        x--; // 继续向上统计
    }

    // 向下统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        x++; // 继续向下统计
    }

    // 向左统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        y--; // 继续向左统计
    }

    // 向右统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        y++; // 继续向右统计
    }
    return sum;
}
```

#### 【一个题目】宝岛探险

小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。10*10的二维矩阵就是钓鱼岛的航拍地图。图中的数字表示海拔，0表示海洋，1~9都表示陆地。小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。

```javascript
/** 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。
 * 注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let sum;

let dfs = function (x, y) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            sum++;
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }

}

book[5][7] = 1;
sum = 1;
dfs(5, 7);


console.log("降落所在的岛屿面积：：", sum)
```

#### 【一个题目】宝岛探险--着色法

​	以某个点为原点对其邻近的点进行着色。比如我们可以将上面的代码稍加改动，将小哼降落的岛都改为-1，表示该岛已经被小哼玩遍。

​	现要实现这个需求只需在 dfs() 函数中加一个参数 color 即可， color 表示该岛屿所需要染的颜色。

```javascript
/** 
 * 着色法改造
 * 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。
 * 注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let sum;

let dfs = function (x, y, color) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    map[x][y] = color; // !!对map[x][y]这个格子进行染色

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            sum++;
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, color); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }

}

book[5][7] = 1;
sum = 1;
let color = -1;
dfs(5, 7, color);


console.log("降落所在的岛屿面积：：", sum, map)
```

#### 【一个题目】宝岛探险--求独立岛屿个数（种子填充法）

​	如果想知道这个地图中有多少个独立的小岛该怎么做呢？很简单，只需要对地图上的每一个**大于0**的点都进行一遍深度优先搜索即可。因为等于0的点是海洋，小于0的点是已经被染色的笑道，我们可以从（1,1）开始，一直枚举到(n,m)，对每个点进行尝试染色。

​	其实就是求一个图中独立子图的个数。这个算法就是大名鼎鼎的**Floodfill漫水填充法**（也称种子填充法）。在计算机图形学中有着非常广泛的运用，比如图像分割、物体识别等等。另外我们熟知的windows下的“画图”软件的油漆桶工具就是基于这个算法的。

```javascript
/** 
 * 运用着色法，求独立岛屿个数
 * 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 
 * 求出独立岛屿个数。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let dfs = function (x, y, color) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    map[x][y] = color; // !!对map[x][y]这个格子进行染色

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, color); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }
}

let color = 0;

function main() {
    // 对每一个大于0的点尝试进行dfs染色
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (map[i][j] > 0) {
                color--; // 小岛需要染的颜色的编号，每发现一个小岛应染以不同的颜色，因此每次都要-1
                book[i][j] = 1;
                dfs(i, j, color);
            }
        }
    }
}

// 程序入口
main();


console.log("独立岛屿个数", -color, map)
```



### bfs 广度优先搜索

#### 队列

- eg:迷宫、炸弹人、宝岛探险

#### 【一个题目】迷宫?

​	小哼解救小哈。迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。注意障碍物是不能走的，且不能走到迷宫之外。你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。

```javascript

```

#### 【一个题目】炸弹人？

```javascript

```

#### 【一个题目】宝岛探险？

小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。10*10的二维矩阵就是钓鱼岛的航拍地图。图中的数字表示海拔，0表示海洋，1~9都表示陆地。小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。

```javascript

```



## 图

### 术语

- 图

  图就是有 N 个顶点和 M 条边组成的集合。

  简单的说，图就是由一些小圆点（称为顶点）和连接这些小圆点的直线（称为边）组成的。

- 有向图

	- 有向边

		- 出边
		- 入边
		- 始点
		- 终点

- 无向图

### 图的存储

#### 邻接矩阵存储法（二维数组）

| 0    | 1    | 1    | ∞    | 1    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | ∞    | 1    | ∞    |
| 1    | ∞    | 0    | ∞    | 1    |
| ∞    | 1    | ∞    | 0    | ∞    |
| 1    | ∞    | 1    | ∞    | 0    |

​	二维数组中第 *i* 行第 *j* 列表示的就是顶点 *i* 到 顶点 *j* 是否有边。1表示有边，∞ 表示没有边，这里我们将自己到自己（即 *i* 等于 *j* ）设为 0 。我们将这种存储图的方法称为**图的邻接矩阵存储法**。

- 稠密图（边M远小于顶点N^2的图）

#### 邻接表存储法（数组？p161）

- 稀疏图（边M相对较大的图）

### 图的深度优先遍历

#### 主要思想

​	首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则回到上一个顶点，继续试探访问别的顶点，知道所有的顶点都被访问过。

- eg:城市地图（两顶点间最短路径）
- 解决权边不相同的情况

### 图的广度优先遍历

#### 主要思想

​	首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点，再访问他们的未被访问过的顶点，直到所有顶点都被访问过，遍历结束。

- eg:最少转机
- 更适合所有边权值相同的情况

## 最短路径

### Floyd-Warshall(弗洛伊德)算法

#### 多源最短路径

​	小哼准备去一些城市旅游。有些城市之间有公路，有些城市之间则没有，为了节省经费以及方便计划旅程，小哼希望在出发前知道**任意两个城市之间的最短路径**。

#### 核心代码

```javascript
for(let k=1;k<=n;k++){
    for(let i=1;i<=n;i++){
        for(let j=1;j<=n;j++){
            if(e[i][j] > e[i][k]+e[k][j]){
                e[i][j] = e[i][k]+e[k][j]
            }
    	}
    }
}
```

​	这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转......允许经过1~n号所有顶点进行中转，求任意两点之间的最短路径。用一句话概括：从 *i* 号顶点到 *j* 号顶点的最短路径。其实这就是一种“动态规划”的思想。

#### 时间复杂度O(N^3)

#### "负权回路"

​	此算法，不能解决带有“负权回路”的图，带有“负权回路”的图没有最短路径。

### Dijkstra(迪杰斯特拉)算法

#### 单源最短路径

​	指定一个点（源点）到其余各个顶点的最短路径。

我们仍然使用二维数组e来存储顶点之间边的关系，用一个一维数组 `dis` 来存储1号顶点到其余各个顶点的初始路程，如下：`dis[0][1][12][∞][∞][∞] `。我们将此时 `dis` 数组中的值称为最短路程的“**估计值**”。

#### 基本思想

​	每次找到离源点（上面栗子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：

1. 将所有的顶点分为两部分：已知最短路径的顶点集合 P 和未知最短路径的顶点集合 Q 。最开始，已知最短路径的顶点集合 P 中只有源点一个顶点。我们这里用一个 book 数组来记录哪些点在集合 P 中。（`book[i]==1` 表示这个顶点 *i* 在顶点集合 P 中，`book[i]==0` 则表示不在）
2. 设置源点 *s* 到自己的最短路径为0，即`dis[s]=0` 。若存在有源点能直接到达的顶点 *i* ，则把`dis[i]`设为`e[s][i]`。同时把所有其他（源点不能直接到达的）顶点的最短路径设为 ∞。
3. 在集合 Q 的所有顶点中选择一个离源点 *s* **最近**的顶点 *u* （即`dis[u]`最小）加入到集合 P 。并考察所有以点 *u* 为起点的边，对每一条边进行**松弛**操作。（例如存在一条从 *u* 到 *v* 的边，那么可以通过将边 u->v 添加到尾部来拓展一条从 *s* 到 *v* 的路径，这条路径的长度是 `dis[u]+e[u][v]`。如果这个值比目前已知的 `dis[v]` 的值要小，我们可以用新值来替代当前 `dis[v]` 中的值。）
4. 重复第3步，如果集合 Q 为空，算法结束。最终 `dis` 数组中的值就是源点到所有顶点的最短路径。

#### 核心代码

```javascript
for(let i=1;i<=n-1;i++){
    // 找到离1号顶点最近的顶点u
    min = inf;
    for(let j=1;j<=n;j++){
        if(book[j] == 0 && dis[j] < min){
            min = dis[j];
            u = j;
        }
    }
    book[u] = 1;
    for(let v=1;v<=n;v++){
        if(e[u][v] < inf){
            if(dis[v] > dis[u]+e[u][v]){
                dis[v] = dis[u]+e[u][v];
            }
        }
    }
}
```

#### 时间复杂度O(N^2)

#### 负权边

​	此算法是一种基于贪心策略的算法。本算法求最短路径的图不能有负权边。

### Bellman–Ford(贝尔曼-福特)算法

#### 解决负权边

#### 完美的最短路算法

#### 核心代码

```javascript
// n为顶点的个数，m为边的个数
for(let k=1;k<=n-1;k++){
    for(let i=1;i<=m;i++){
        if(dis[v[i]] > dis[u[i]] + w[i]){
            dis[v[i]] = dis[u[i]] + w[i]
        }
    }
}
```



#### 时间复杂度O(M*N)

### 队列优化的Bellman–Ford

### 最短路径算法对比分析

## 树

### 什么是树

- 是不包含回路的无向图
- 树的特点
- 运用场景

### 二叉树

- 满二叉树
- 完全二叉树

	- 一维数组存储
	- 规律

		- 最后一个非叶子节点是第n/2个节点

### 堆Heap

- 一种特殊的完全二叉树
- 优先队列

	- 支持插入元素和寻找最大（小）值元素的数据结构

- 最小堆
- 最大堆
- 堆排序：时间复杂度O(N*logN)
- eg:求一个数列中第K大（小）的树，O(N*logK)

### 并查集

- 通过一个一维数组实现
- 不相交集数据结构

## 更多

### 最小生成树

- eg:镖局运镖
- Kruskal算法

	- 时间复杂度O(M*logM)，M是边数
	- 适用于稀疏图

- Prim算法

	- 未堆优化

		- 时间复杂度O(N^2)
		- 适用于稠密图

	- 堆优化后

		- 时间复杂度O(M*logN)
		- 适用于稀疏图

### 图的割点

- eg:重要城市
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

### 图的割边

- eg:关键道路
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

- 可见一个算法要选择合适的数据结构是非常重要的

### 二分图最大匹配

- 二分图定义
- 增广路
- eg:我要做月老
- 时间复杂度O(M*N)
- 运用场景

	- 任务调度
	- 工作安排

- 使用着色法判断二分图

*XMind: ZEN - Trial Version*