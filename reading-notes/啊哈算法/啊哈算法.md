# 啊哈算法

[TOC]

## 排序

### 桶排序

- 时间复杂度O(M+N)
- 对空间要求大

### 冒泡排序

- 【交换】
- 时间复杂度O(N^2)

### 快速排序

- 【折半】
- 时间复杂度O(N*logN)

## 队列、栈、链表

### 队列queue

#### 原则：先进先出 FIFO

#### 结构体类型：data\head\tail

```c
struct queue
{
    int data[100];// 队列的主体，用来存储内容
    int head;// 队首
    int tail;// 队尾
};

// head == tail 说明是空队列
```

#### 场景：排队买票

### 栈stack

#### 原则：后进先出

#### 结构体类型：data\top

```c
struct stack
{
	int data[10];
    int top;
};

// top == 0 说明是空栈
```

#### 场景：浏览器前进后退、回文、{}符号闭合

> 判断回文思路：
>
> 1. 创建栈s[]；
> 2. 找到栈的中间位置mid（把栈分为 A 和 B 两部分）；
> 3. 循环 B ，一一和栈 A 的栈顶对比，相等则出栈 top--；
> 4. 最后 top == 0，则说明是回文。

```c
#include <stdio.h> 
#include <string.h> 
int main() 
{ 
 char a[101],s[101]; 
 int i,len,mid,next,top; 
 
 gets(a); //读入一行字符串
 len=strlen(a); //求字符串的长度
 mid=len/2-1; //求字符串的中点
 
 top=0;//栈的初始化
 //将mid前的字符依次入栈
 for(i=0;i<=mid;i++) 
 s[++top]=a[i]; 
 
 //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 
 if(len%2==0) 
 next=mid+1; 
 else 
 next=mid+2; 
 
 //开始匹配
 for(i=next;i<=len-1;i++)
 { 
 if(a[i]!=s[top]) 
 break; 
 top--; 
 } 
 
 //如果top的值为0，则说明栈内所有的字符都被一一匹配了
 if(top==0) 
 printf("YES"); 
 else 
 printf("NO"); 
 getchar();getchar(); 
 return 0; 
}
```



### 纸牌游戏（队列和栈的应用）

​	游戏的规则是这样的：将一副扑克牌平均分成两份，每人拿一份。小哼先拿出手中的第一张扑克牌放在桌上，然后小哈也拿出手中的第一张扑克牌，并放在小哼刚打出的扑克牌的上面，就像这样两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，即可将两张相同的牌及其中间所夹的牌全部取走，并依次放到自己手中牌的末尾。当任意一人手中的牌全部出完时，游戏结束，对手获胜。

> 解题思路：
>
> 小哼有两种操作，分别是出牌和赢牌。这恰好对应队列的两个操作，出牌就是出队，赢牌就是入队。小哈的操作和小哼是一样的。
>
> 而桌子就是一个栈，每打出一张牌放到桌上就相当于入栈。当有人赢牌的时候，依次将牌从桌上拿走，这就相当于出栈。
>
> 那如何解决赢牌的问题呢？赢牌的规则是：如果某人打出的牌与桌上的某张牌相同，即可将两张牌以及中间所夹的牌全部取走。
>
> 1. 初始化2个队列q1，q2（先进先出），用于存储小哼小哈手里的牌；初始化1个栈s（后进先出），用于存储桌面上的牌；
> 2. q1非空 且 q2非空时，循环步骤3-4；
> 3. 小哼出牌，判断小哼当前是否赢牌`book[t]==1`（t是当前牌）；若赢牌，则小哼队列q1+赢的牌，桌面栈s-赢的牌，桌面标记取消此牌`book[s.data[s.top]]=0`；若不赢，则小哼队列q1--，桌面栈s++；
> 4. 小哈出牌，逻辑同小哼；
> 5. q1空了，小哼输牌；q2空了，小哈输牌。

```c
#include <stdio.h> 
struct queue 
{ 
 int data[1000]; 
 int head; 
 int tail; 
};
struct stack 
{ 
 int data[10]; 
 int top; 
}; 
int main() 
{ 
 struct queue q1,q2; 
 struct stack s; 
 int book[10]; 
 int i,t; 
 
 //初始化队列
 q1.head=1; q1.tail=1; 
 q2.head=1; q2.tail=1; 
 //初始化栈
 s.top=0; 
 //初始化用来标记的数组，用来标记哪些牌已经在桌上
 for(i=1;i<=9;i++) 
 book[i]=0; 
 
 //依次向队列插入6个数
 //小哼手上的6张牌
 for(i=1;i<=6;i++) 
 { 
 scanf("%d",&q1.data[q1.tail]); 
 q1.tail++; 
 } 
 //小哈手上的6张牌
 for(i=1;i<=6;i++) 
 { 
 scanf("%d",&q2.data[q2.tail]); 
 q2.tail++; 
 } 
 while(q1.head<q1.tail && q2.head<q2.tail ) //当队列不为空的时候执行循环
 { 
 t=q1.data[q1.head];//小哼出一张牌
 //判断小哼当前打出的牌是否能赢牌
 if(book[t]==0) //表明桌上没有牌面为t的牌
     { 
 //小哼此轮没有赢牌
 q1.head++; //小哼已经打出一张牌，所以要把打出的牌出队
 s.top++; 
 s.data[s.top]=t; //再把打出的牌放到桌上，即入栈
 book[t]=1; //标记桌上现在已经有牌面为t的牌
 } 
 else 
 { 
 //小哼此轮可以赢牌
 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队
 q1.data[q1.tail]=t;//紧接着把打出的牌放到手中牌的末尾
 q1.tail++; 
 while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾
 { 
 book[s.data[s.top]]=0;//取消标记
 q1.data[q1.tail]=s.data[s.top];//依次放入队尾
 q1.tail++; 
 s.top--; //栈中少了一张牌，所以栈顶要减1 
 } 
 } 
 
 t=q2.data[q2.head]; //小哈出一张牌
 //判断小哈当前打出的牌是否能赢牌
 if(book[t]==0) //表明桌上没有牌面为t的牌
 { 
 //小哈此轮没有赢牌
 q2.head++; //小哈已经打出一张牌，所以要把打出的牌出队
 s.top++; 
 s.data[s.top]=t; //再把打出的牌放到桌上，即入栈
 book[t]=1; //标记桌上现在已经有牌面为t的牌 
 } 
 else 
 { 
 //小哈此轮可以赢牌
 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队
 q2.data[q2.tail]=t;//紧接着把打出的牌放到手中牌的末尾
 q2.tail++; 
 while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾
 { 
 book[s.data[s.top]]=0;//取消标记
     q2.data[q2.tail]=s.data[s.top];//依次放入队尾
 q2.tail++; 
 s.top--; 
 } 
 } 
 } 
 
 if(q2.head==q2.tail) 
 { 
 printf("小哼win\n"); 
 printf("小哼当前手中的牌是"); 
 for(i=q1.head;i<=q1.tail-1;i++) 
 printf(" %d",q1.data[i]); 
 if(s.top>0) //如果桌上有牌则依次输出桌上的牌
 { 
 printf("\n桌上的牌是"); 
 for(i=1;i<=s.top;i++) 
 printf(" %d",s.data[i]); 
 } 
 else 
 printf("\n桌上已经没有牌了"); 
 } 
 else 
 { 
 printf("小哈win\n"); 
 printf("小哈当前手中的牌是"); 
 for(i=q2.head;i<=q2.tail-1;i++) 
 printf(" %d",q2.data[i]); 
 if(s.top>0) //如果桌上有牌则依次输出桌上的牌
 { 
 printf("\n桌上的牌是"); 
 for(i=1;i<=s.top;i++) 
 printf(" %d",s.data[i]); 
 } 
 else 
 printf("\n桌上已经没有牌了"); 
 } 
 
 getchar();getchar(); 
 return 0; 
}
```



### 链表

#### 指针

```c
int *p;// 定义指针p，一个存放整数的内存空间
double *p;// 定义指针q，一个存放浮点数的内存空间

// & 取地址符
p=&a;// 指针p获取变量a的地址

// * 间接运算符，用于获取指针p所指向的内存中的值
*p;
```

#### 动态分配内存函数malloc

```c
int *p;//定义一个指针p
p=(int *)malloc(sizeof(int));//指针p获取动态分配的内存空间地址
*p=10;//向指针p所指向的内存中存入10
```

#### 结构体类型

```c
struct node
{
    int data;
    struct node *next;
};
```

#### 模拟链表

链表还有另外一种使用数组来实现的方式，叫做模拟链表。

链表中的每一个结点只有两部分。我们可以用一个数组 `data[]` 来存储序列中的每一个数；用另一个数组 `right[]` 来存放序列中每一个数右边的数是谁（这里存储的是 `data[]` 的下标哦）。

## 搜索

### dfs 深度优先搜索

#### 递归

- 解决当前应该怎么办
- eg:全排列、迷宫

#### dfs的基本模型

```c
void dfs(int step)
{
	判断边界
    尝试每一种可能 for(i=1;i<=n;i++)
    {
        继续下一步 dfs(step+1)
    }
    返回
}
```

#### 【一个题目】全排列

手中有编号为1~9的九张扑克牌，排列使得`[][][]+[][][]=[][][]`成立，注意A+B=C和B+A=C属于同一种组合，求一共有多少种组合？

- 枚举法（暴力解）

  ```javascript
  // 枚举法（暴力解）
  let enumeration = function () {
      let a, b, c, d, e, f, g, h, i, total = 0;
      for (a = 1; a <= 9; a++) { // 第一个数的百位
          for (b = 1; b <= 9; b++) { // 第一个数的十位
              for (c = 1; c <= 9; c++) { // 第一个数的个位
  
                  for (d = 1; d <= 9; d++) { // 第二个数的百位
                      for (e = 1; e <= 9; e++) { // 第二个数的十位
                          for (f = 1; f <= 9; f++) { // 第二个数的个位
  
                              for (g = 1; g <= 9; g++) { // 第三个数的百位
                                  for (h = 1; h <= 9; h++) { // 第三个数的十位
                                      for (i = 1; i <= 9; i++) { // 第三个数的个位
  
                                          if (a != b && a != c && a != d && a != e && a != f && a != g && a != h && a != i &&
                                              b != c && b != d && b != e && b != f && b != g && b != h && b != i &&
                                              c != d && c != e && c != f && c != g && c != h && c != i &&
                                              d != e && d != f && d != g && d != h && d != i &&
                                              e != f && e != g && e != h && e != i &&
                                              f != g && f != h && f != i &&
                                              g != h && g != i &&
                                              h != i &&
                                              (a * 100 + b * 10 + c) + (d * 100 + e * 10 + f) == g * 100 + h * 10 + i) {
                                              total++;
                                          }
  
                                      }
                                  }
                              }
  
                          }
                      }
                  }
  
              }
          }
      }
      return total / 2
  }
  console.log('枚举法（暴力解）::', enumeration())
  ```

  

- 标记法（用 book[] 来解决互不相等的问题）

  ```javascript
  // 标记法（用 book[] 来解决互不相等的问题）
  let bookExec = function () {
      let a = new Array(10),
          i,
          total = 0,
          book = new Array(10),
          sum;
      for (a[1] = 1; a[1] <= 9; a[1]++) { // 第一个数的百位
          for (a[2] = 1; a[2] <= 9; a[2]++) { // 第一个数的十位
              for (a[3] = 1; a[3] <= 9; a[3]++) { // 第一个数的个位
  
                  for (a[4] = 1; a[4] <= 9; a[4]++) { // 第二个数的百位
                      for (a[5] = 1; a[5] <= 9; a[5]++) { // 第二个数的十位
                          for (a[6] = 1; a[6] <= 9; a[6]++) { // 第二个数的个位
  
                              for (a[7] = 1; a[7] <= 9; a[7]++) { // 第三个数的百位
                                  for (a[8] = 1; a[8] <= 9; a[8]++) { // 第三个数的十位
                                      for (a[9] = 1; a[9] <= 9; a[9]++) { // 第三个数的个位
  
                                          book.fill(0); // 初始化 book[]
                                          for (i = 1; i <= 9; i++) {
                                              book[a[i]] = 1; // 如果某个数出现过就标记
                                          }
                                          // 统计出现了多少个不同的数
                                          sum = 0;
                                          for (i = 1; i <= 9; i++) {
                                              sum += book[i]
                                          }
  
                                          // 如果正好出现9个不同的数，且满足等式条件
                                          if (sum == 9 && (a[1] * 100 + a[2] * 10 + a[3]) + (a[4] * 100 + a[5] * 10 + a[6]) == (a[7] * 100 + a[8] * 10 + a[9])) {
                                              total++;
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
      return total / 2
  }
  console.log('标记法::', bookExec()) // 执行发现，标记法好慢哦！
  ```

- 递归（深度优先遍历搜索）

  ```javascript
  // 递归（深度优先遍历搜索）
  let a = new Array(10),
      book = new Array(10).fill(0),
      total = 0;
  let dfs = function (step = 1) {
      let i;
      if (step == 10) { // 站在了第十个盒子前，说明前9个盒子已装好扑克牌
          if ((a[1] * 100 + a[2] * 10 + a[3]) + (a[4] * 100 + a[5] * 10 + a[6]) == (a[7] * 100 + a[8] * 10 + a[9])) {
              total++;
          }
      }
      // 此时站在第step个盒子面前，该放哪个扑克牌呢？
      // 按照1，2，...n一一尝试
      for (i = 1; i <= 9; i++) {
          if (book[i] == 0) { // 说明牌i还在手上
              a[step] = i; // 将牌i放入第step个盒子中
              book[i] = 1; // 标记牌i已不在手上
  
              dfs(step + 1); // 走到下一个盒子面前，递归
              book[i] = 0; // 一定要将刚才尝试的牌收回！！
          }
      }
  }
  dfs();
  console.log('递归（深度优先遍历搜索）::', total / 2)
  ```

#### 【一个题目】迷宫

​	小哼解救小哈。迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。注意障碍物是不能走的，且不能走到迷宫之外。你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。

```javascript
/**
 * 小哼解救小哈。
 * 迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。
 * 注意障碍物是不能走的，且不能走到迷宫之外。
 * 你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。
 */

// 初始化一个5行4列的迷宫，1表示障碍物
let n = 5,
    m = 4;
let map = [
    [0, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1]
]
// 小哈所在的位置
let p = 3,
    q = 2;


// 用来标记迷宫上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
]
let min = 999999; // 存储最短路径

let dfs = function (x, y, step) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    // 判断找到小哈，并返回最短路径
    if (x == p && y == q) {
        min = Math.min(step, min)
    }

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是障碍物 && 未走过
        if (map[tx][ty] == 0 && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, step + 1); // 尝试下一点
            book[tx][ty] = 0; // 取消这个点的标记
        }
    }

}
dfs(0, 0, 0);
console.log("找到小哈需要走的最短路径：：", min)
```

#### 【一个题目】炸弹人

```javascript
/**
 * 炸弹人
 * 
 */


// 初始化一个13行13列的迷宫，#表示墙，G表示敌人，.表示空地
let n = 13,
    m = 13;
let map = [
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', 'G', 'G', '.', '#'],
    ['#', '#', '#', '.', '#', 'G', '#', 'G', '#', 'G', '#', 'G', '#'],
    ['#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', 'G', '#'],
    ['#', 'G', '#', '.', '#', '#', '#', '.', '#', 'G', '#', 'G', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '.', '#', '.', 'G', 'G', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', '.', '#', '.', '#', '.', '#'],
    ['#', '#', 'G', '.', '.', '.', 'G', '.', '.', '.', '.', '.', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', '#', '#', '.', '#', 'G', '#'],
    ['#', '.', '.', '.', 'G', '#', 'G', 'G', 'G', '.', 'G', 'G', '#'],
    ['#', 'G', '#', '.', '#', 'G', '#', 'G', '#', '.', '#', 'G', '#'],
    ['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', '.', 'G', 'G', '#'],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#']
]

// 用来标记迷宫上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]
let max = 0,
    mx, my;

let dfs = function (x, y) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k, sum = 0;

    sum = getNum(x, y);
    if (sum > max) {
        max = sum;
        mx = x; // 记录当前点的坐标
        my = y;
    }

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点是空地 && 未走过
        if (map[tx][ty] == '.' && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记-----这一行不执行也可以
        }
    }

}
dfs(3, 3);
console.log(`将炸弹放在（${mx},${my}）处，最多可消灭 ${max} 个敌人`)


// 【帮助方法】计算每个点上可消除的敌人数
function getNum(i, j) {
    let sum, x, y;
    sum = 0;

    // 向上统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        x--; // 继续向上统计
    }

    // 向下统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        x++; // 继续向下统计
    }

    // 向左统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        y--; // 继续向左统计
    }

    // 向右统计可以消灭的敌人数
    x = i;
    y = j;
    while (map[x][y] != '#') { // 判断如果不是墙就继续
        if (map[x][y] == 'G') { // 如果是敌人，则计数
            sum++;
        }
        y++; // 继续向右统计
    }
    return sum;
}
```

#### 【一个题目】宝岛探险

小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。10*10的二维矩阵就是钓鱼岛的航拍地图。图中的数字表示海拔，0表示海洋，1~9都表示陆地。小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。

```javascript
/** 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。
 * 注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let sum;

let dfs = function (x, y) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            sum++;
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }

}

book[5][7] = 1;
sum = 1;
dfs(5, 7);


console.log("降落所在的岛屿面积：：", sum)
```

#### 【一个题目】宝岛探险--着色法

​	以某个点为原点对其邻近的点进行着色。比如我们可以将上面的代码稍加改动，将小哼降落的岛都改为-1，表示该岛已经被小哼玩遍。

​	现要实现这个需求只需在 dfs() 函数中加一个参数 color 即可， color 表示该岛屿所需要染的颜色。

```javascript
/** 
 * 着色法改造
 * 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。
 * 注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let sum;

let dfs = function (x, y, color) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    map[x][y] = color; // !!对map[x][y]这个格子进行染色

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            sum++;
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, color); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }

}

book[5][7] = 1;
sum = 1;
let color = -1;
dfs(5, 7, color);


console.log("降落所在的岛屿面积：：", sum, map)
```

#### 【一个题目】宝岛探险--求独立岛屿个数（种子填充法）

​	如果想知道这个地图中有多少个独立的小岛该怎么做呢？很简单，只需要对地图上的每一个**大于0**的点都进行一遍深度优先搜索即可。因为等于0的点是海洋，小于0的点是已经被染色的笑道，我们可以从（1,1）开始，一直枚举到(n,m)，对每个点进行尝试染色。

​	其实就是求一个图中独立子图的个数。这个算法就是大名鼎鼎的**Floodfill漫水填充法**（也称种子填充法）。在计算机图形学中有着非常广泛的运用，比如图像分割、物体识别等等。另外我们熟知的windows下的“画图”软件的油漆桶工具就是基于这个算法的。

```javascript
/** 
 * 运用着色法，求独立岛屿个数
 * 
 * 小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。
 * 钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。
 * 10*10的二维矩阵就是钓鱼岛的航拍地图。
 * 图中的数字表示海拔，0表示海洋，1~9都表示陆地。
 * 
 * 求出独立岛屿个数。
 */


// 初始化一个10行10列的岛屿，0表示海洋，1~9都表示陆地
let n = 10,
    m = 10;
let map = [
    [1, 2, 1, 0, 0, 0, 0, 0, 2, 3],
    [3, 0, 2, 0, 1, 2, 1, 0, 1, 2],
    [4, 0, 1, 0, 1, 2, 3, 2, 0, 1],
    [3, 2, 0, 0, 0, 1, 2, 4, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 5, 3, 0],
    [0, 1, 2, 1, 0, 1, 5, 4, 3, 0],
    [0, 1, 2, 3, 1, 3, 6, 2, 1, 0],
    [0, 0, 3, 4, 8, 9, 7, 5, 0, 0],
    [0, 0, 0, 3, 7, 8, 6, 0, 1, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

// 用来标记岛屿上某一点有没有走过，1表示走过
let book = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

let dfs = function (x, y, color) {
    // 下一步是四种走法
    let next = [
        [0, 1], // 向右走
        [1, 0], // 向下走
        [0, -1], // 向左走
        [-1, 0] // 向上走
    ]

    let tx, ty, k;

    map[x][y] = color; // !!对map[x][y]这个格子进行染色

    // 循环下一步的四种走法
    for (k = 0; k <= 3; k++) {

        // 计算下一点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];

        // 越界退出
        if (tx < 0 || tx > n - 1 || ty < 0 || ty > m - 1) {
            continue; // !!注意，仅需跳出本次循环即可
        }

        // 判断有效点，即该点不是海洋 && 未走过
        if (map[tx][ty] > 0 && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记该点走过
            dfs(tx, ty, color); // 尝试下一点
            // book[tx][ty] = 0; // 取消这个点的标记，不需要
        }
    }
}

let color = 0;

function main() {
    // 对每一个大于0的点尝试进行dfs染色
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (map[i][j] > 0) {
                color--; // 小岛需要染的颜色的编号，每发现一个小岛应染以不同的颜色，因此每次都要-1
                book[i][j] = 1;
                dfs(i, j, color);
            }
        }
    }
}

// 程序入口
main();


console.log("独立岛屿个数", -color, map)
```



### bfs 广度优先搜索

#### 队列

- eg:迷宫、炸弹人、宝岛探险

#### 【一个题目】迷宫?

​	小哼解救小哈。迷宫由`n`行`m`列的单元格组成（`n` 和 `m` 都小于等于50），每个单元格要么是空地，要么是障碍物。注意障碍物是不能走的，且不能走到迷宫之外。你的任务是帮助小哼找到一条从迷宫的**起点**通往小哈所在位置的最短路径。

```javascript

```

#### 【一个题目】炸弹人？

```javascript

```

#### 【一个题目】宝岛探险？

小哼通过秘密方法得到一张不完整的钓鱼岛航拍地图。钓鱼岛由一个主岛和一些附属岛屿组成，小哼决定去钓鱼岛探险。10*10的二维矩阵就是钓鱼岛的航拍地图。图中的数字表示海拔，0表示海洋，1~9都表示陆地。小哼的飞机将会降落在(6,8)处，现在需要计算出小哼降落地所在岛的面积（即有多少个格子）。注意此处我们把与小哼降落点上下左右相连接的陆地均视为同一岛屿。

```javascript

```



## 图

### 术语

- 图

  图就是有 N 个顶点和 M 条边组成的集合。

  简单的说，图就是由一些小圆点（称为顶点）和连接这些小圆点的直线（称为边）组成的。

- 有向图

	- 有向边

		- 出边
		- 入边
		- 始点
		- 终点

- 无向图

### 图的存储

#### 邻接矩阵存储法（二维数组）

| 0    | 1    | 1    | ∞    | 1    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | ∞    | 1    | ∞    |
| 1    | ∞    | 0    | ∞    | 1    |
| ∞    | 1    | ∞    | 0    | ∞    |
| 1    | ∞    | 1    | ∞    | 0    |

​	二维数组中第 *i* 行第 *j* 列表示的就是顶点 *i* 到 顶点 *j* 是否有边。1表示有边，∞ 表示没有边，这里我们将自己到自己（即 *i* 等于 *j* ）设为 0 。我们将这种存储图的方法称为**图的邻接矩阵存储法**。

- 稠密图（边M远小于顶点N^2的图）

#### 邻接表存储法（数组？p161）

- 稀疏图（边M相对较大的图）

### 图的深度优先遍历

#### 主要思想

​	首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则回到上一个顶点，继续试探访问别的顶点，知道所有的顶点都被访问过。

- eg:城市地图（两顶点间最短路径）
- 解决权边不相同的情况

### 图的广度优先遍历

#### 主要思想

​	首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点，再访问他们的未被访问过的顶点，直到所有顶点都被访问过，遍历结束。

- eg:最少转机
- 更适合所有边权值相同的情况

## 最短路径

### Floyd-Warshall(弗洛伊德)算法

#### 多源最短路径

​	小哼准备去一些城市旅游。有些城市之间有公路，有些城市之间则没有，为了节省经费以及方便计划旅程，小哼希望在出发前知道**任意两个城市之间的最短路径**。

#### 核心代码

```c
for(k=1;k<=n;k++){
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            if(e[i][j] > e[i][k]+e[k][j]){
                e[i][j] = e[i][k]+e[k][j]
            }
    	}
    }
}
```

​	这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转......允许经过1~n号所有顶点进行中转，求任意两点之间的最短路径。用一句话概括：从 *i* 号顶点到 *j* 号顶点的最短路径。其实这就是一种“动态规划”的思想。

#### 时间复杂度O(N^3)

#### "负权回路"

​	此算法，不能解决带有“负权回路”的图，带有“负权回路”的图没有最短路径。

### Dijkstra(迪杰斯特拉)算法

#### 单源最短路径

​	指定一个点（源点）到其余各个顶点的最短路径。

我们仍然使用二维数组e来存储顶点之间边的关系，用一个一维数组 `dis` 来存储1号顶点到其余各个顶点的初始路程，如下：`dis[0][1][12][∞][∞][∞] `。我们将此时 `dis` 数组中的值称为最短路程的“**估计值**”。

#### 基本思想

​	每次找到离源点（上面栗子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：

1. 将所有的顶点分为两部分：已知最短路径的顶点集合 P 和未知最短路径的顶点集合 Q 。最开始，已知最短路径的顶点集合 P 中只有源点一个顶点。我们这里用一个 book 数组来记录哪些点在集合 P 中。（`book[i]==1` 表示这个顶点 *i* 在顶点集合 P 中，`book[i]==0` 则表示不在）
2. 设置源点 *s* 到自己的最短路径为0，即`dis[s]=0` 。若存在有源点能直接到达的顶点 *i* ，则把`dis[i]`设为`e[s][i]`。同时把所有其他（源点不能直接到达的）顶点的最短路径设为 ∞。
3. 在集合 Q 的所有顶点中选择一个离源点 *s* **最近**的顶点 *u* （即`dis[u]`最小）加入到集合 P 。并考察所有以点 *u* 为起点的边，对每一条边进行**松弛**操作。（例如存在一条从 *u* 到 *v* 的边，那么可以通过将边 u->v 添加到尾部来拓展一条从 *s* 到 *v* 的路径，这条路径的长度是 `dis[u]+e[u][v]`。如果这个值比目前已知的 `dis[v]` 的值要小，我们可以用新值来替代当前 `dis[v]` 中的值。）
4. 重复第3步，如果集合 Q 为空，算法结束。最终 `dis` 数组中的值就是源点到所有顶点的最短路径。

#### 核心代码

```c
for(i=1;i<=n-1;i++){
    
    // 找到离1号顶点最近的顶点u
    min = inf;
    for(j=1;j<=n;j++){
        if(book[j] == 0 && dis[j] < min){
            min = dis[j];
            u = j;
        }
    }
    
    book[u] = 1;
    for(v=1;v<=n;v++){
        if(e[u][v] < inf){
            if(dis[v] > dis[u]+e[u][v]){
                dis[v] = dis[u]+e[u][v];
            }
        }
    }
}
```

#### 时间复杂度O(N^2)

#### “负权边”

​	此算法是一种基于贪心策略的算法。本算法求最短路径的图不能有负权边。

### Bellman–Ford(贝尔曼-福特)算法

#### 单源最短路径

​	指定一个点（源点）到其余各个顶点的最短路径。

最短路径肯定是一个不包含回路的简单路径。

#### 解决负权边

#### 完美的最短路算法

​	对所有的边进行 n-1 次“松弛”操作。

还可以检测一个图是否含有负权回路，如果在进行 n-1 轮松弛之后，仍然存在：

```c
if(dis[v[i]] > dis[u[i]] + w[i]){
	dis[v[i]] = dis[u[i]] + w[i]
}
```

的情况，也就是说在进行 n-1 轮松弛之后，仍然可以继续成功松弛，那么此图必然存在负权回路。

#### 核心代码

```c
// n为顶点的个数，m为边的个数

// u、v、w三个数组是用来记录边的信息
// 例如：第 i 条边存储在 u[i]、v[i]、w[i]中，表示从 顶点u[i] 到 顶点v[i] 这条边的权值为 w[i]

for(k=1;k<=n-1;k++){ // n 个顶点的图中，任意两点之间的最短路径最多包含 n-1 边
    for(i=1;i<=m;i++){ // 松弛每一条边
        if(dis[v[i]] > dis[u[i]] + w[i]){
            dis[v[i]] = dis[u[i]] + w[i]
        }
    }
}
```

#### 检测负权回路

```c
// Bellman-Ford 算法核心语句
for(k=1;k<=n-1;k++){ 
    for(i=1;i<=m;i++){ 
        if(dis[v[i]] > dis[u[i]] + w[i]){
            dis[v[i]] = dis[u[i]] + w[i]
        }
    }
}

// 检测负权回路
flag = 0;
for(i=1;i<=m;i++){
    if(dis[v[i]] > dis[u[i]] + w[i]){
        flag = 1;//flag为1表示含有负权回路
    }
}
```

#### 代码优化

```c
// Bellman-Ford 算法核心语句
for(k=1;k<=n-1;k++){ 
    // 将dis数组备份至bak数组中
    for(i=1;i<=n;i++){
        bak[i] = dis[i];
    }
    // 进行一轮松弛
    for(i=1;i<=m;i++){ 
        if(dis[v[i]] > dis[u[i]] + w[i]){
            dis[v[i]] = dis[u[i]] + w[i]；
        }
    }
    // 松弛完毕后检测dis数组是否有更新
    check = 0;
    for(i=1;i<=n;i++){
        if(bak[i] != dis[i]){
            check = 1;
            break;
        }
    }
    if(check == 0){
        break;// 如果 dis 数组没有更新，提前退出循环结束算法
    }    
}
```

#### 时间复杂度O(N*M)

### 队列优化的Bellman–Ford？P175



### 最短路径算法对比分析

|                | Floyd                        | Dijkstra                      | Bellman-Ford              | 队列优化的Bellman-Ford    |
| -------------- | ---------------------------- | ----------------------------- | ------------------------- | ------------------------- |
| **空间复杂度** | O(N^2)                       | O(M)                          | O(M)                      | O(M)                      |
| **时间复杂度** | O(N^3)                       | O((M+N)logN)                  | O(NM)                     | 最坏O(NM)                 |
| **适用情况**   | 稠密图<br>（和顶点关系密切） | 稠密图<br/>（和顶点关系密切） | 稀疏图<br/>(和边关系密切) | 稀疏图<br/>(和边关系密切) |
| **负权**       | 可以解决负权                 | 不能解决负权                  | 可以解决负权              | 可以解决负权              |

​	**Floyd**算法虽然总体时间复杂度高，但是可以解决负权边，并且均摊到每一点上，在所有的算法中还是属于较优的。另外，**Floyd**算法较小的编码复杂度也是它的一大优势。所以，如果要求的是所有点之间的最短路径，或者如果数据范围较小，则**Floyd**算法比较适合。

​	**Dijkstra**算法最大的弊端就是无法适应有负权边的图。但是**Dijkstra**算法有良好的可扩展性，扩展后可以适应很多问题。另外堆优化的**Dijkstra**算法的时间复杂度可以达到O(MlogN)。

​	当边有负权时，需要使用**Bellman-Ford**算法或者队列优化的**Bellman-Ford**算法。

因此我们选择最短路径算法时，要根据需求和每一种算法的特性，选择适合的算法。

## 树

### 什么是树

- 是不包含回路的无向图

#### 树的特点

1. 一棵树中的任意两个节点有且仅有唯一的一条路径联通。
2. 一棵树如果有n个节点，那么他一定恰好有n-1条边。
3. 在一棵树中加一条边将会构成一个回路

#### 运用场景

- 足球世界杯晋级图
- 家族的族谱图
- 公司的组织结构图
- 书的目录

### 二叉树

#### 定义

​	二叉树的特点是每个节点最多有两个儿子，左边的叫左儿子，右边的叫右儿子。

严格定义：二叉树要么为空，要么由根节点、左子树和右子树构成，而左子树和右子树分别是一棵二叉树。

#### 满二叉树

​	如果二叉树中每个内部节点都有两个儿子，这样的二叉树叫做满二叉树。

严格定义：一棵深度为h ,且有2<sup>h</sup>-1个节点的二叉树。

#### 完全二叉树

​	如果一棵二叉树除了最右边位置上有一个或者几个叶子节点缺少外，其他是丰满的，那么这样的二叉树就是完全二叉树。

严格定义：若设二叉树的高度为h，除第h层外，其他各层（1~h-1）的节点数都达到最大个数，第h层从右向左连续缺若干节点，则这个二叉树就是完全二叉树。也就是说，如果一个节点有右子节点，那么它一定也有左子节点。

- 一维数组存储
- 规律
- 父节点是k，则左子节点是2k，右子节点是2k+1；
	- 左/右子节点是x，则父节点是x/2；
	- 最后一个非叶子节点是第n/2个节点

### 堆Heap

#### 一种特殊的完全二叉树

- 最小堆：所有父节点都比子节点小；
- 最大堆：所有父节点都比子节点大；

#### 创建堆

1. 方式一

   - 从空的堆开始，然后依次往堆中插入每一个元素，再根据情况判断新元素是否需要上移，直到满足堆的特性为止。最终将所有元素都插入。

   - 时间复杂度：O(NlogN)。（插入第i个元素所用的时间是O(logi)）

   - ```c
     n=0;
     for(i=1;i<=m;i++){
         n++;
         h[n]=a[i];
         shftip();
     }
     ```

2. 方式二

   - 将所有数放入一个完全二叉树中（用一个一维数组来存储完全二叉树）。我们从最后一个节点开始，一次判断以这个节点为根的子树是否符合最小堆的特性。直到所有的子树都符合最小堆的特性，即得到了最小堆。所有叶子节点均满足最小堆特性，因此只需从最后一个非叶子节点（节点编码为n/2）开始到根节点（节点编码为1），诸葛扫描所有的节点，根据需要将当前节点向下调整，直到以当前节点为根节点的子树都符合堆的特性。

   - 时间复杂度：O(N)。

   - ```c
     for(i=n/2;i>=1;i--){
     	shftdown(i)
     }
     ```

#### 堆排序

​	堆排序的实现很简单，比如我们现在要进行从小到大排序，可以先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。

- 时间复杂度：O(NlogN)

#### 运用场景

- 求一个数列中第K大的数

  解析：需要建立一个大小为K的最小堆，堆顶就是第K大的数。时间复杂度O(N*logK)。

- 求一个数列中第K小的数

  解析：需要建立一个大小为K的最大堆，堆顶就是第K小的数。时间复杂度O(N*logK)。

### 并查集

​	并查集通过一个一维数组来实现，其本质是维护一个森林。刚开始的时候，森林的每个点都是孤立的，也可以理解为每个点就是一棵只有一个节点的树，之后通过一些条件，逐渐将这些树合并成一棵大树。其实合并的过程就是“认爹”的过程。在“认爹”的过程中，要遵守“靠左”原则和“擒贼先擒王”原则。在每次判断两个节点是否已经在同一棵树中的时候（一棵树其实就是一个集合），也要注意必须求其根源，中间父亲节点（“小BOSS”）是不能说明问题的，必须找到其祖宗（树的根节点），判断两个节点的祖宗是否是同一个根节点才行。

- 通过一个一维数组实现
- 不相交集数据结构

## 更多

### 图的最小生成树

#### 一个栗子【镖局运镖】

​	N个城市，以及M条城市间道路，每条边的权值不同（即走这条路花费的银子）。

​	镖局现在需要选择一些道路进行疏通，以便镖局可以到达任意一个城镇，要求是花费的银子越少越好。换句话说，镖局的要求就是用最少的边让图连通（任意两点之间可以互相到达），其实就是将多余的边去掉。很显然，要想让有n个顶点的图连通，那么至少需要n-1条边。

​	如果一个连通无向图不包含回路，那么这就是一棵树，其实这里就是求一个图的最小生成树。

#### 最小生成树之Kruskal算法

- 基本思想

  首先按照边的权值进行从小到达排序，每次从剩余的边中选择权值较小且边的两个顶点不在同一个集合内的边（就是不会产生回路的边）加入到生成树中，直到加入了n-1条边为止。

- 难点

  如何判断两个顶点是否**已连通**？

  （可以使用深度优先搜索或者广度优先搜索，但效率低；可以使用并查集，将所有的顶点放入一个并查集中，判断两个顶点是否联通，置需判断两个顶点是否在同一个集合中即可，这样时间复杂度仅为O(logN)）。

- 时间复杂度O(M*logM)，M是边数

- 适用于稀疏图

#### 最小生成树之Prim算法

- 基本思想

  我们将图中所有的顶点分为两类：树顶点（已被选入生成树的顶点）和非树顶点（还未被选入生成树的顶点）。首先选择任意一个顶点加入生成树（你可以理解成为生成树的根）。接下来要找出一条边添加到生成树，这需要枚举每一个树顶点到每一个非树顶点所有的边，然后找到最短边加入到生成树。照此方法，重复n-1次，直到将所有顶点都加入生成树中。

- 难点

  如何找出下一个添加到生成树的边？

  借用dijkstra算法，用数组dis来记录“生成树”到各个顶点的距离，也就是说现在记录的最短距离，不是每一个顶点到1号顶点的最短距离，而是每个顶点到任意一个“树顶点”（已被选入生成树的顶点）的最短距离，即如果`dis[k]>e[j][k](1<=k<=n)`，则更新`dis[k]=e[j][k]`。

- 算法步骤

  1. 从任意一个顶点开始构造生成树，假设就从1号顶点吧。首先将顶点1加入生成树中，用一个一维数组book来标记哪些顶点已经加入了生成树；
  2. 用数组dis记录生成树到各个顶点的距离。最初生成树中只有1号顶点，有直连边时，数组dis 中存储的就是1号顶点到该顶点的边的权值，没有直连边的时候就是无穷大，即初始化dis数组；
  3. 从数组dis中选出离生成树最近的顶点（假设这个顶点为j）加入到生成树中（即在数组dis中找最小值）.再以j为中间点，更新生成树到每一个非树顶点的距离（就是松弛啦），即如果`dis[k]>e[j][k](1<=k<=n)`，则更新`dis[k]=e[j][k]`。
  4. 重复第3部，直到生成树中有n个顶点为止。

- 未堆优化

	- 时间复杂度O(N^2)
	- 适用于稠密图

- 堆优化后

	- 时间复杂度O(M*logN)
	- 适用于稀疏图

### 图的割点

- eg:重要城市
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

### 图的割边

- eg:关键道路
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

- 可见一个算法要选择合适的数据结构是非常重要的

### 二分图最大匹配

- 二分图定义
- 增广路
- eg:我要做月老
- 时间复杂度O(M*N)
- 运用场景

	- 任务调度
	- 工作安排

- 使用着色法判断二分图

*XMind: ZEN - Trial Version*