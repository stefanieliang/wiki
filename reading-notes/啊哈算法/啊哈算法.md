# 啊哈算法

[TOC]

## 排序

### 桶排序

- 时间复杂度O(M+N)
- 对空间要求大

### 冒泡排序

- 【交换】
- 时间复杂度O(N^2)

### 快速排序

- 【折半】
- 时间复杂度O(N*logN)

## 队列、栈、链表

### 队列queue

- 原则：先进先出 FIFO

- 结构体类型：data\head\tail

  ```c
  struct queue
  {
      int data[100];// 队列的主体，用来存储内容
      int head;// 队首
      int tail;// 队尾
  };
  
  // head == tail 说明是空队列
  ```

- 场景：排队买票

### 栈stack

- 原则：后进先出

- 结构体类型：data\top

  ```c
  struct stack
  {
  	int data[10];
      int top;
  };
  
  // top == 0 说明是空栈
  ```

- 场景：浏览器前进后退、回文、{}符号闭合

  > 判断回文思路：
  >
  > 1. 创建栈s[]；
  > 2. 找到栈的中间位置mid（把栈分为 A 和 B 两部分）；
  > 3. 循环 B ，一一和栈 A 的栈顶对比，相等则出栈 top--；
  > 4. 最后 top == 0，则说明是回文。

  ```c
  #include <stdio.h> 
  #include <string.h> 
  int main() 
  { 
   char a[101],s[101]; 
   int i,len,mid,next,top; 
   
   gets(a); //读入一行字符串
   len=strlen(a); //求字符串的长度
   mid=len/2-1; //求字符串的中点
   
   top=0;//栈的初始化
   //将mid前的字符依次入栈
   for(i=0;i<=mid;i++) 
   s[++top]=a[i]; 
   
   //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 
   if(len%2==0) 
   next=mid+1; 
   else 
   next=mid+2; 
   
   //开始匹配
   for(i=next;i<=len-1;i++)
   { 
   if(a[i]!=s[top]) 
   break; 
   top--; 
   } 
   
   //如果top的值为0，则说明栈内所有的字符都被一一匹配了
   if(top==0) 
   printf("YES"); 
   else 
   printf("NO"); 
   getchar();getchar(); 
   return 0; 
  }
  ```

  

### 纸牌游戏--队列和栈的应用

​	游戏的规则是这样的：将一副扑克牌平均分成两份，每人拿一份。小哼先拿出手中的第一张扑克牌放在桌上，然后小哈也拿出手中的第一张扑克牌，并放在小哼刚打出的扑克牌的上面，就像这样两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，即可将两张相同的牌及其中间所夹的牌全部取走，并依次放到自己手中牌的末尾。当任意一人手中的牌全部出完时，游戏结束，对手获胜。

> 解题思路：
>
> 小哼有两种操作，分别是出牌和赢牌。这恰好对应队列的两个操作，出牌就是出队，赢牌就是入队。小哈的操作和小哼是一样的。
>
> 而桌子就是一个栈，每打出一张牌放到桌上就相当于入栈。当有人赢牌的时候，依次将牌从桌上拿走，这就相当于出栈。
>
> 那如何解决赢牌的问题呢？赢牌的规则是：如果某人打出的牌与桌上的某张牌相同，即可将两张牌以及中间所夹的牌全部取走。
>
> 1. 初始化2个队列q1，q2（先进先出），用于存储小哼小哈手里的牌；初始化1个栈s（后进先出），用于存储桌面上的牌；
> 2. q1非空 且 q2非空时，循环步骤3-4；
> 3. 小哼出牌，判断小哼当前是否赢牌`book[t]==1`（t是当前牌）；若赢牌，则小哼队列q1+赢的牌，桌面栈s-赢的牌，桌面标记取消此牌`book[s.data[s.top]]=0`；若不赢，则小哼队列q1--，桌面栈s++；
> 4. 小哈出牌，逻辑同小哼；
> 5. q1空了，小哼输牌；q2空了，小哈输牌。

```c
#include <stdio.h> 
struct queue 
{ 
 int data[1000]; 
 int head; 
 int tail; 
};
struct stack 
{ 
 int data[10]; 
 int top; 
}; 
int main() 
{ 
 struct queue q1,q2; 
 struct stack s; 
 int book[10]; 
 int i,t; 
 
 //初始化队列
 q1.head=1; q1.tail=1; 
 q2.head=1; q2.tail=1; 
 //初始化栈
 s.top=0; 
 //初始化用来标记的数组，用来标记哪些牌已经在桌上
 for(i=1;i<=9;i++) 
 book[i]=0; 
 
 //依次向队列插入6个数
 //小哼手上的6张牌
 for(i=1;i<=6;i++) 
 { 
 scanf("%d",&q1.data[q1.tail]); 
 q1.tail++; 
 } 
 //小哈手上的6张牌
 for(i=1;i<=6;i++) 
 { 
 scanf("%d",&q2.data[q2.tail]); 
 q2.tail++; 
 } 
 while(q1.head<q1.tail && q2.head<q2.tail ) //当队列不为空的时候执行循环
 { 
 t=q1.data[q1.head];//小哼出一张牌
 //判断小哼当前打出的牌是否能赢牌
 if(book[t]==0) //表明桌上没有牌面为t的牌
     { 
 //小哼此轮没有赢牌
 q1.head++; //小哼已经打出一张牌，所以要把打出的牌出队
 s.top++; 
 s.data[s.top]=t; //再把打出的牌放到桌上，即入栈
 book[t]=1; //标记桌上现在已经有牌面为t的牌
 } 
 else 
 { 
 //小哼此轮可以赢牌
 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队
 q1.data[q1.tail]=t;//紧接着把打出的牌放到手中牌的末尾
 q1.tail++; 
 while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾
 { 
 book[s.data[s.top]]=0;//取消标记
 q1.data[q1.tail]=s.data[s.top];//依次放入队尾
 q1.tail++; 
 s.top--; //栈中少了一张牌，所以栈顶要减1 
 } 
 } 
 
 t=q2.data[q2.head]; //小哈出一张牌
 //判断小哈当前打出的牌是否能赢牌
 if(book[t]==0) //表明桌上没有牌面为t的牌
 { 
 //小哈此轮没有赢牌
 q2.head++; //小哈已经打出一张牌，所以要把打出的牌出队
 s.top++; 
 s.data[s.top]=t; //再把打出的牌放到桌上，即入栈
 book[t]=1; //标记桌上现在已经有牌面为t的牌 
 } 
 else 
 { 
 //小哈此轮可以赢牌
 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队
 q2.data[q2.tail]=t;//紧接着把打出的牌放到手中牌的末尾
 q2.tail++; 
 while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾
 { 
 book[s.data[s.top]]=0;//取消标记
     q2.data[q2.tail]=s.data[s.top];//依次放入队尾
 q2.tail++; 
 s.top--; 
 } 
 } 
 } 
 
 if(q2.head==q2.tail) 
 { 
 printf("小哼win\n"); 
 printf("小哼当前手中的牌是"); 
 for(i=q1.head;i<=q1.tail-1;i++) 
 printf(" %d",q1.data[i]); 
 if(s.top>0) //如果桌上有牌则依次输出桌上的牌
 { 
 printf("\n桌上的牌是"); 
 for(i=1;i<=s.top;i++) 
 printf(" %d",s.data[i]); 
 } 
 else 
 printf("\n桌上已经没有牌了"); 
 } 
 else 
 { 
 printf("小哈win\n"); 
 printf("小哈当前手中的牌是"); 
 for(i=q2.head;i<=q2.tail-1;i++) 
 printf(" %d",q2.data[i]); 
 if(s.top>0) //如果桌上有牌则依次输出桌上的牌
 { 
 printf("\n桌上的牌是"); 
 for(i=1;i<=s.top;i++) 
 printf(" %d",s.data[i]); 
 } 
 else 
 printf("\n桌上已经没有牌了"); 
 } 
 
 getchar();getchar(); 
 return 0; 
}
```



### 链表

- 指针
- 动态分配内存函数malloc

## 搜索

### dfs 深度优先搜索

- 递归

	- 解决当前应该怎么办
	- eg:全排列、迷宫

### bfs 广度优先搜索

- 队列

	- eg:迷宫、炸弹人、宝岛探险

## 图

### 术语

- 图
- 有向图

	- 有向边

		- 出边
		- 入边
		- 始点
		- 终点

- 无向图

### 图的存储

- 二维数组存储
- 图的邻接矩阵存储法

	- 稠密图

### 图的深度优先遍历

- 主要思想
- eg:城市地图

### 图的广度优先遍历

- 主要思想
- eg:最少转机
- 更适合所有边权值相同的情况

## 最短路径

### Floyd-Warshall(弗洛伊德)算法

- 多源最短路径
- 核心代码
- 时间复杂度O(N^3)
- "负权回路"没有最短路径

### Dijkstra(迪杰斯特拉)算法

- 单源最短路径
- 核心代码
- 时间复杂度O((M+N)*logN)
- 使用数组实现邻接表

	- 稀疏图

- 基于贪心策略，不能有负权边

### Bellman–Ford(贝尔曼-福特)算法

- 解决负权边
- 完美的最短路算法
- 核心代码
- 时间复杂度O(M*N)

### 队列优化的Bellman–Ford

### 最短路径算法对比分析

## 树

### 什么是树

- 是不包含回路的无向图
- 树的特点
- 运用场景

### 二叉树

- 满二叉树
- 完全二叉树

	- 一维数组存储
	- 规律

		- 最后一个非叶子节点是第n/2个节点

### 堆Heap

- 一种特殊的完全二叉树
- 优先队列

	- 支持插入元素和寻找最大（小）值元素的数据结构

- 最小堆
- 最大堆
- 堆排序：时间复杂度O(N*logN)
- eg:求一个数列中第K大（小）的树，O(N*logK)

### 并查集

- 通过一个一维数组实现
- 不相交集数据结构

## 更多

### 最小生成树

- eg:镖局运镖
- Kruskal算法

	- 时间复杂度O(M*logM)，M是边数
	- 适用于稀疏图

- Prim算法

	- 未堆优化

		- 时间复杂度O(N^2)
		- 适用于稠密图

	- 堆优化后

		- 时间复杂度O(M*logN)
		- 适用于稀疏图

### 图的割点

- eg:重要城市
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

### 图的割边

- eg:关键道路
- 使用邻接矩阵存储

	- 时间复杂度O(N^2)

- 使用邻接表存储

	- 时间复杂度O(N+M)

- 可见一个算法要选择合适的数据结构是非常重要的

### 二分图最大匹配

- 二分图定义
- 增广路
- eg:我要做月老
- 时间复杂度O(M*N)
- 运用场景

	- 任务调度
	- 工作安排

- 使用着色法判断二分图

*XMind: ZEN - Trial Version*